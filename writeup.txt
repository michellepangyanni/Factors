COMP 321 Project 1: Factors
<Michelle Pang, yp29>

---(Do not write lines of text that exceed the width of this line.)------------

TESTING STRATEGY

Black Box:
1. n is commons
2. n is repeating
3. n is non-repeating
4. n is evens
5. n is odds

1. The input is 0; should return "Invalid input: 0"
3. The input is 1; should return "Invalid input: 1"
4. The input is a prime (>1) that can be factorized.
5. The input is a composite (non-prime) that can be factorized.
6. The input's factorization includes more than one distinct prime
7. The input's factorization includes repeats
8. The input's factorization includes non-repeats
8. The input is a prime that is too large to be factorized.
9. The input is a composite that is too large to be factorized.
10. The input is a very large (> 10000) prime that can be factorized.
11. The input is a very large (> 10000) composite that can factorized.

White Box: (categorized by function)

For count_factors_recursiveï¼š
    1. input's the smallest prime, 2, to test if the last prime is reached for the base case in count_factors_helper function 
    2. input's a large non-prime, to ensure the first case in the recursive step 
    -- when input is not prime, it is still divisible by factor of 2 -- works
    eg. n = 4294967295, n = 987654321
    3. input's a large prime, to make sure my iterative method is complete and efficient in the recursive step 
    -- when the input could be prime, then increment counter until we find Case1 or find that num is prime
		that its only prime factor is itself.
        eg. n = 999331, n = 115249
    4. input = 1 or input = 0, should return "Invalid input: 1" or "Invalid input: 0"

For count_factors:
    1. input's the smallest prime, 2, to test that the input's last prime is reached and counted
    2. input's an odd number to ensure that every odd input's primes factors can be counted through the 
    for-loop in count_factors correctly
    eg. 59, 77
    2. input's an even number to ensure that every even's prime factors can be counted. 
    eg. 22, 36
    4. Input has prime factors that are not 2 or 3, to test the last condition that n > 2 and n is its own prime factor
    eg. n = 13, n = 97

For count_distinct_factors:
    1. Input's only have distinct prime factors to test that we are not counting all the normal prime factors of n.
    eg. n = 323, n = 15
    2. Input has both distinct and non-distict prime factors to test that these two types of primes can be counted separately
    eg. n = 99, n = 56
    3. Input has one distict, repeating prime factor, which is equivalent 
    to input's have only non-distict prime factor, to test that the function 
    also works for numbers that only have one prime factor so that only 1 factor is distinct.
    eg. n = 32, n = 64, n = 128

1. Input's an invalid input 
    eg. n = 1
2. Input's the smallest prime 
    eg. n = 2
3. Input's'prime factors are the same as its non-prime factors
    eg. n = 6
4. Input has one distict, repeating prime factor, 
which is equivalent to input's have only non-distict prime factor
    eg. n = 32, n = 64, n = 128
5. Input has prime factors that are not 2 or 3
    eg. n = 13, n = 97
6. Input's a large prime 
    eg. n = 999331, n = 115249
7. Input's a large non-prime 
    n = 987654321
8. Input's square of a prime 
    eg. n = 169, n = 9
9. Input's have only distinct prime factors
    eg. n = 323, n = 15
10. Input's have both distinct and non-distict prime factors
    eg. n = 99, n = 56

//Do I need more explanation? 
More:
These inputs are sufficient to test that I am counting only the 
prime factors and not counting the normal factors.
First, I divide the input n by 2, the lowest prime number, until 
n could not be divided anymore to ensure that 
the base case 2 works before anything else...


SOMETHING I LEARNED

<C does not have boolean data types that it uses integers for boolean testing.
That is, there is no truth or false in C, instead, 0 is used to represent false, 
and 1 is used to represent true.>
